from contextlib import contextmanager, ExitStack
import re

import bqplot
import pandas as pd
import regions

from novt import footprints as fp
from novt.constants import INSTRUMENT_NAMES, DEFAULT_COLOR

__all__ = ['hold_all_sync', 'bqplot_footprint', 'bqplot_catalog',
           'remove_bqplot_patches']


@contextmanager
def hold_all_sync(marks):
    """
    Hold sync for a set of bqplot marks.

    Each mark entry will have its own hold_sync context manager invoked,
    so that syncing is performed only when all changes on the marks are
    complete.

    Parameters
    ----------
    marks : list of bqplot.Mark
        A list of patches to update together.
    """
    with ExitStack() as stack:
        for mark in marks:
            stack.enter_context(mark.hold_sync())
        yield


def bqplot_footprint(figure, instrument, ra, dec, pa, wcs,
                     dither_pattern=None, add_mosaic=False,
                     mosaic_offset=None,
                     color=None, visible=True, fill='inside',
                     alpha=1.0, fill_alpha=0.5, update_patches=None):
    """
    Create an instrument footprint as an overlay in a bqplot figure.

    Overlays are created from sky regions calculated in `novt.footprints`.
    Sky coordinates are translated to pixel coordinates using the input
    WCS structure. Aperture overlay marks are closed polygon regions
    implemented as `bqplot.Lines`. The center position is marked with a
    single-point `bqplot.Scatter` mark.

    For improved performance, patches may be updated in place by passing
    them in the `update_patches` parameter.  In this case, the number and
    order of marks passed in must match the number and order of regions
    newly generated by the footprints function for the input instrument
    configuration.

    Patches added to the figure remain until they are explicitly
    removed. The `remove_bqplot` function may be used to remove any
    patches no longer needed.

    Parameters
    ----------
    figure : bqplot.Figure
        The bqplot figure to add aperture overlays to.
    instrument : {'NIRSpec', 'NIRCam Short', 'NIRCam Long'}
        The instrument to display.
    ra : float
        RA of instrument center, in degrees.
    dec : float
        Dec of instrument center, in degrees.
    pa : float
        Position angle for instrument, in degrees measured from North
        to central MSA vertical axis in North to East direction.
    wcs : astropy.wcs.WCS
        WCS structure, used to translate sky coordinates to pixel positions
        in the displayed image.
    dither_pattern : str, optional
        Name of the NIRCam dither pattern to apply.  Options are: NONE, FULL3,
        FULL3TIGHT, FULL6, 8NIRSPEC. Ignored if `instrument` is NIRSpec.
    add_mosaic : bool or str, optional
        If False or 'No', mosaic offsets are ignored. Otherwise, a two-tile
        mosaic is computed with window width specified in `mosaic_offset`.
    mosaic_offset : tuple or list, optional
        (V2, V3) offset in telescope coordinates to apply as a two-tile
        mosaic offset.  The offset is specified as a window width around
        the pointing center: the mosaic position will be at the center +/-
        offset / 2. Ignored if `dither_pattern` is 8NIRSPEC or `instrument`
        is NIRSpec or `add_mosaic` is not set.
    color : str, optional
        Color to apply to the aperture footprint. If not specified, default
        colors are applied.
    visible : bool, optional
        If False, the overlay is added to the figure but initially hidden.
    fill : str, optional
        Fill option to pass to `bqplot.Lines`.
    alpha : float, optional
        Opacity setting for the overlay border.
    fill_alpha : float, optional
        Opacity setting for the overlay fill.
    update_patches : list of bqplot.Mark, optional
        If provided, no new patches are created; the marks in `update_patches`
        are updated in place. This option can improve performance, but
        can only be used if the number and type of new patches exactly
        matches the input patches.

    Returns
    -------
    marks : list of bqplot.Mark
        Marks added to the figure.
    """
    # standardize input
    inst = re.sub(r'\s', '_', instrument.strip().lower())
    inst = INSTRUMENT_NAMES[inst]

    dither_pattern = str(dither_pattern).strip().upper()

    if not isinstance(add_mosaic, bool):
        if str(add_mosaic).lower() in {'no', 'false', '0', 'none'}:
            add_mosaic = False
        else:
            add_mosaic = True

    # get footprint configuration by instrument
    if color is None:
        color = DEFAULT_COLOR[inst]

    # make regions
    if inst == 'NIRSpec':
        regs = fp.nirspec_footprint(ra, dec, pa)
    else:
        # 'NIRCam Short' or 'NIRCam Long'
        channel = inst.split()[-1].lower()
        regs = fp.nircam_dither_footprint(
            ra, dec, pa, channel=channel,
            dither_pattern=dither_pattern,
            add_mosaic=add_mosaic,
            mosaic_offset=mosaic_offset)

    # get scales from figure
    scales = {'x': figure.interaction.x_scale, 'y': figure.interaction.y_scale}

    marks = []
    for i, reg in enumerate(regs):
        pixel_region = reg.to_pixel(wcs)
        if isinstance(pixel_region, regions.PointPixelRegion):
            if update_patches is not None:
                mark = update_patches[i]
                with mark.hold_sync():
                    mark.x = [pixel_region.center.x]
                    mark.y = [pixel_region.center.y]
                    mark.colors = [color]
                    mark.default_opacities = [alpha]
            else:
                # instrument center point
                mark = bqplot.Scatter(x=[pixel_region.center.x],
                                      y=[pixel_region.center.y],
                                      scales=scales, colors=[color],
                                      marker='plus')
                mark.default_opacities = [alpha]
        else:
            x_coords = pixel_region.vertices.x
            y_coords = pixel_region.vertices.y
            if update_patches is not None:
                mark = update_patches[i]
                with mark.hold_sync():
                    mark.x = x_coords
                    mark.y = y_coords
                    mark.fill = fill
                    mark.colors = [color]
                    mark.opacities = [alpha]
                    mark.fill_opacities = [fill_alpha]
            else:
                # instrument aperture regions
                mark = bqplot.Lines(x=x_coords, y=y_coords, scales=scales,
                                    fill=fill, colors=[color], stroke_width=2,
                                    close_path=True, opacities=[alpha],
                                    fill_opacities=[fill_alpha])

        mark.visible = visible
        marks.append(mark)

    if update_patches is None:
        figure.marks = figure.marks + marks
    return marks


def bqplot_catalog(figure, catalog_file, wcs,
                   colors=None, visible=True, fill=False, alpha=1.0):
    """
    Create a catalog source overlay on a bqplot figure.

    Overlays are created directly from an input catalog file containing
    RA and Dec sky coordinates for primary and filler sources.  The input
    WCS structure is used to convert the coordinates to pixel positions.
    The catalog is implemented as two `bqplot.Scatter` overlays: one for
    the primary sources, and one for the filler sources.

    The input catalog is in '.radec' form.  Three whitespace-separated
    columns are expected: RA, Dec, and flag.  RA and Dec must be in degrees.
    The flag may be 'P' for primary source or 'F' for filler.

    Parameters
    ----------
    figure : bqplot.Figure
        The bqplot figure to add catalog overlays to.
    catalog_file : str
        Path to a .radec catalog file.
    wcs : astropy.wcs.WCS
        WCS structure, used to translate sky coordinates to pixel positions
        in the displayed image.
    colors : list of str, optional
        If provided, must be a 2-element list or tuple of color names for
        primary and filler sources, in that order. If not provided, default
        colors will be assigned.
    visible : bool, optional
        If False, the overlay is added to the figure but initially hidden.
    fill : bool, optional
        Fill option to pass to `bqplot.Scatter`.
    alpha : float, optional
        Opacity setting for the overlay.

    Returns
    -------
    marks : list of bqplot.Mark
        Marks added to the figure.
    """
    if colors is None:
        colors = [DEFAULT_COLOR['Primary Sources'],
                  DEFAULT_COLOR['Filler Sources']]

    # load the source catalog
    catalog = pd.read_table(catalog_file, names=['ra', 'dec', 'flag'],
                            delim_whitespace=True, usecols=[0, 1, 2])

    # sort by flag
    filler = (catalog['flag'] == 'F')
    primary = ~filler

    fill_x, fill_y = wcs.wcs_world2pix(
        catalog['ra'][filler], catalog['dec'][filler], 0)

    primary_x, primary_y = wcs.wcs_world2pix(
        catalog['ra'][primary], catalog['dec'][primary], 0)

    # get scales from figure
    scales = {'x': figure.interaction.x_scale, 'y': figure.interaction.y_scale}

    # scatter plot for primary markers
    primary_markers = bqplot.Scatter(
        x=primary_x, y=primary_y, scales=scales, colors=[colors[0]],
        marker='circle', fill=fill)
    primary_markers.visible = visible
    primary_markers.default_opacities = [alpha]

    # scatter plot for filler markers
    filler_markers = bqplot.Scatter(
        x=fill_x, y=fill_y, scales=scales, colors=[colors[1]],
        marker='circle', fill=fill)
    filler_markers.visible = visible
    filler_markers.default_opacities = [alpha]

    # place catalog markers at the front of the list, so it always appears
    # behind any other overlays
    figure.marks = [filler_markers, primary_markers] + figure.marks

    return primary_markers, filler_markers


def remove_bqplot_patches(figure, patches):
    """
    Remove patches from a bqplot figure.

    Parameters
    ----------
    figure : bqplot.Figure
        The figure to update.
    patches : list of bqplot.Mark
        The patches to remove.
    """
    marks = figure.marks.copy()
    for patch in patches:
        try:
            marks.remove(patch)
        except ValueError:
            continue
    figure.marks = marks
